#+TITLE: Emacs-lisp Packaging Tips
* 谁应该读这个文档
刚刚从写 Emacs configure 转到写 emacs package 的同学建议读一下
这个文档
* Configure 和 package 有什么区别
从 Emacs-lisp 语言角度来说，没有多大的区别，可能写 package 的时候，
Emacs-lisp 应用的更加规范一点。

我认为最大的不同可能是编写时遵循的理念：
1. Configure 是写给自己用的，如果其他同学使用你的 configure 出了问题，
   你可以不负任何责任。
2. Package 主要是写给其他人使用的，如果出了问题，维护者是有直接
   责任的:-)

所以，写 package 的时候，维护者需要遵守更多的隐性惯例。
* 编写 package 应遵循的惯例
** 无恶意原则
*** 不能有恶意代码
*** 不能偷偷的窃取用户隐私。
** 成本效益原则
*** 不能毫无理由的重复制造轮子

** 尊重用户选择的原则
Package 可以给用户提供更多的选择，但做为 package 的维护者，你不能随意
的替用户做决定。

*** 不可以随意的定义全局变量
在 Emacs 中，用户变量往往是全局变量，所以 package 维护者不能随意的
定义全局变量，特别要注意的是：不可以仅使用 setq 来定义变量。

setq 这个操作符是 *变量赋值* 操作符，不是 *变量定义* 操作符，
但如果被赋值的变量不存在，它会定义这个 *全局变量*, 然后再赋值。
写 configure 的时候，我们为了省事，习惯用它来定义一个变量，

但写 package 的时候，这个功能就有其他风险，以下面一句代码为例子：

#+BEGIN_SRC emacs-lisp
(setq xxx "xxx")
#+END_SRC

如果 xxx 是一个其他 package 的全局变量或者用户变量，就有可能会出现
一些意想不到的问题，短的变量更容易出问题，因为 emacs-lisp 核心代码
使用的全局变量比较短， 比如：name

常见的定义全局变量的方式有两种：
1. 定义一个用户变量
   #+BEGIN_SRC emacs-lisp
   (defcustom elptips-name "elptips-name"
     "Elptips's name.")
   #+END_SRC
2. 定义一个普通的全局变量
   #+BEGIN_SRC emacs-lisp
   (defvar elptips-name "elptips-name"
     "Elptips's name.")
   #+END_SRC

*** 不能随意覆盖你自己 package 的用户变量
如果你在自己 package 中用 defcustom 定义了一个用户变量，你就不可以
随意的覆盖它，比如：

#+BEGIN_EXAMPLE emacs-lisp
(defcustom elptips-name nil)
(setq elptips-name "elptips-name2")
#+END_EXAMPLE

或者：

#+BEGIN_EXAMPLE emacs-lisp
(defvar elptips-name nil)
(setq elptips-name "elptips-name2")
#+END_EXAMPLE

这样做之后，你就变相的为用户做了选择，有可能给用户会带来困扰。

*** 不能随意覆盖其他 package 用户变量
用户变量就是在 package 中，使用 defcustom 定义的变量，这些变量是
留给用户设置的，不能随意覆盖，否则出现问题后，使用者很难发现哪里
出现了问题。

*** 不能随意覆盖其他 package 的内部变量
如果随意覆盖其他 package 的内部变量，很有可能会让这个包运行异常，
而且很难发现问题出现在哪里。
